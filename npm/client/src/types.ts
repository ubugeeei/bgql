/**
 * Core types for the bgql client.
 */

// =============================================================================
// TypedDocumentNode - Full Type Inference Support
// =============================================================================

/**
 * A typed document node that preserves the data and variables types.
 * This enables full type inference when executing GraphQL operations.
 *
 * @example
 * ```typescript
 * // Generated by bgql codegen
 * const GetUserDocument: TypedDocumentNode<
 *   { user: { id: string; name: string } },
 *   { id: string }
 * > = gql`
 *   query GetUser($id: ID!) {
 *     user(id: $id) {
 *       id
 *       name
 *     }
 *   }
 * `;
 *
 * // Full type inference
 * const result = await client.executeTyped(GetUserDocument, { id: '1' });
 * // result.value is typed as { user: { id: string; name: string } }
 * ```
 */
export interface TypedDocumentNode<TData = unknown, TVariables = Record<string, unknown>> {
  /** Phantom property to hold the data type */
  readonly __resultType?: TData;
  /** Phantom property to hold the variables type */
  readonly __variablesType?: TVariables;
  /** Metadata about the document */
  readonly __meta?: {
    readonly operationName: string;
    readonly operationType: 'query' | 'mutation' | 'subscription';
    readonly source: string;
  };
}

/**
 * Extracts the data type from a TypedDocumentNode.
 */
export type ResultOf<T> = T extends TypedDocumentNode<infer TData, unknown> ? TData : never;

/**
 * Extracts the variables type from a TypedDocumentNode.
 */
export type VariablesOf<T> = T extends TypedDocumentNode<unknown, infer TVariables> ? TVariables : never;

/**
 * Configuration options for creating a bgql client.
 */
export interface ClientConfig {
  /**
   * The GraphQL endpoint URL.
   */
  readonly url: string;

  /**
   * Default headers to include in every request.
   */
  readonly headers?: Record<string, string>;

  /**
   * Timeout for requests in milliseconds.
   * @default 30000
   */
  readonly timeout?: number;

  /**
   * Fetch implementation to use.
   * @default globalThis.fetch
   */
  readonly fetch?: typeof fetch;

  /**
   * Retry configuration.
   */
  readonly retry?: RetryConfig;

  /**
   * Custom error handler for logging/reporting.
   */
  readonly onError?: (error: unknown) => void;

  /**
   * Credentials mode for fetch.
   * @default 'same-origin'
   */
  readonly credentials?: RequestCredentials;
}

/**
 * Retry configuration.
 */
export interface RetryConfig {
  /**
   * Maximum number of retries.
   * @default 3
   */
  readonly maxRetries?: number;

  /**
   * Initial delay between retries in milliseconds.
   * @default 1000
   */
  readonly initialDelayMs?: number;

  /**
   * Maximum delay between retries in milliseconds.
   * @default 30000
   */
  readonly maxDelayMs?: number;

  /**
   * Whether to use exponential backoff.
   * @default true
   */
  readonly exponentialBackoff?: boolean;

  /**
   * Custom retry condition.
   */
  readonly shouldRetry?: (error: unknown, attempt: number) => boolean;
}

/**
 * Options for a single operation request.
 */
export interface RequestOptions {
  /**
   * AbortSignal for cancellation.
   */
  readonly signal?: AbortSignal;

  /**
   * Additional headers for this request.
   */
  readonly headers?: Record<string, string>;

  /**
   * Timeout override for this request.
   */
  readonly timeout?: number;

  /**
   * Context passed to middleware.
   */
  readonly context?: Record<string, unknown>;
}

/**
 * A GraphQL operation (query, mutation, subscription).
 */
export interface Operation<TVariables, TData> {
  /**
   * The operation name.
   */
  readonly operationName: string;

  /**
   * The operation type.
   */
  readonly operationType: 'query' | 'mutation' | 'subscription';

  /**
   * The GraphQL document string.
   */
  readonly document: string;

  /**
   * Variables for the operation.
   */
  readonly variables?: TVariables;
}

/**
 * GraphQL response from the server.
 */
export interface GraphQLResponse<TData> {
  readonly data?: TData;
  readonly errors?: ReadonlyArray<GraphQLErrorResponse>;
  readonly extensions?: Record<string, unknown>;
}

/**
 * GraphQL error in the response.
 */
export interface GraphQLErrorResponse {
  readonly message: string;
  readonly locations?: ReadonlyArray<{ line: number; column: number }>;
  readonly path?: ReadonlyArray<string | number>;
  readonly extensions?: Record<string, unknown>;
}

/**
 * Partial data with deferred fields.
 */
export type PartialData<T> = {
  [K in keyof T]: T[K] extends object
    ? PartialData<T[K]> | Promise<T[K]>
    : T[K];
};

/**
 * Streaming result for @defer/@stream.
 */
export interface StreamingResult<TData> {
  /**
   * Initial data (may have deferred fields).
   */
  readonly data: PartialData<TData>;

  /**
   * Whether there are more chunks coming.
   */
  readonly hasNext: boolean;

  /**
   * Async iterator for incremental updates.
   */
  readonly incremental?: AsyncIterable<IncrementalUpdate<TData>>;
}

/**
 * Incremental update from @defer/@stream.
 */
export interface IncrementalUpdate<TData> {
  readonly path: ReadonlyArray<string | number>;
  readonly data: Partial<TData>;
  readonly hasNext: boolean;
}

/**
 * Subscription observable.
 */
export interface Subscription<TData> {
  /**
   * Subscribe to updates.
   */
  subscribe(handlers: {
    next: (data: TData) => void;
    error?: (error: unknown) => void;
    complete?: () => void;
  }): Unsubscribe;
}

/**
 * Function to unsubscribe from a subscription.
 */
export type Unsubscribe = () => void;

/**
 * Middleware function for request/response interception.
 */
export type Middleware = (
  operation: Operation<unknown, unknown>,
  options: RequestOptions,
  next: (
    operation: Operation<unknown, unknown>,
    options: RequestOptions
  ) => Promise<GraphQLResponse<unknown>>
) => Promise<GraphQLResponse<unknown>>;

/**
 * Generated client operation methods.
 * This is a placeholder - actual types are generated from schema.
 */
export interface GeneratedOperations {
  [key: string]: (
    variables?: unknown,
    options?: RequestOptions
  ) => Promise<unknown>;
}

// =============================================================================
// Branded Types for Type-Safe IDs
// =============================================================================

/**
 * Creates a branded type for nominal typing.
 *
 * @example
 * ```typescript
 * type UserId = Brand<string, 'UserId'>;
 * type PostId = Brand<string, 'PostId'>;
 *
 * const userId: UserId = 'user_123' as UserId;
 * const postId: PostId = 'post_456' as PostId;
 *
 * // Error: Type 'UserId' is not assignable to type 'PostId'
 * const wrong: PostId = userId;
 * ```
 */
export type Brand<T, B extends string> = T & { readonly __brand: B };

/**
 * Helper to create branded values.
 */
export function brand<T, B extends string>(value: T): Brand<T, B> {
  return value as Brand<T, B>;
}

/**
 * Extracts the base type from a branded type.
 */
export type Unbrand<T> = T extends Brand<infer U, string> ? U : T;

// =============================================================================
// Option Type (for Option<T> from schema)
// =============================================================================

/**
 * Represents an optional value.
 * Maps to Option<T> in bgql schema.
 */
export type Option<T> = T | null;

/**
 * Checks if an Option has a value.
 */
export function isSome<T>(option: Option<T>): option is T {
  return option !== null;
}

/**
 * Checks if an Option is empty.
 */
export function isNone<T>(option: Option<T>): option is null {
  return option === null;
}

/**
 * Maps an Option value.
 */
export function mapOption<T, U>(
  option: Option<T>,
  fn: (value: T) => U
): Option<U> {
  return option !== null ? fn(option) : null;
}

/**
 * Unwraps an Option with a default value.
 */
export function unwrapOption<T>(option: Option<T>, defaultValue: T): T {
  return option !== null ? option : defaultValue;
}

// =============================================================================
// Extended Client Configuration Types
// =============================================================================

/**
 * Extended client configuration with all optional features.
 */
export interface ExtendedClientConfig extends ClientConfig {
  /**
   * Enable request deduplication.
   * Same queries with same variables will share a single request.
   * @default false
   */
  readonly dedupe?: boolean;

  /**
   * Enable automatic query batching.
   * Multiple queries will be batched into a single HTTP request.
   * @default false
   */
  readonly batch?: boolean | BatchOptions;

  /**
   * Enable normalized caching.
   * Entities are cached by type and ID for efficient updates.
   * @default false
   */
  readonly cache?: boolean | CacheOptions;
}

/**
 * Options for automatic query batching.
 */
export interface BatchOptions {
  /**
   * Maximum number of operations per batch.
   * @default 10
   */
  readonly maxSize?: number;

  /**
   * Maximum time to wait before executing a batch (ms).
   * @default 10
   */
  readonly interval?: number;
}

/**
 * Options for caching.
 */
export interface CacheOptions {
  /**
   * Time-to-live for cache entries (ms).
   * @default 300000 (5 minutes)
   */
  readonly ttl?: number;

  /**
   * Use normalized cache (entities by type/id).
   * @default true
   */
  readonly normalized?: boolean;
}

// =============================================================================
// Utility Types for Query Results
// =============================================================================

/**
 * Makes specified fields deeply partial.
 */
export type DeepPartial<T> = T extends object
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : T;

/**
 * Makes all fields non-nullable recursively.
 */
export type DeepNonNullable<T> = T extends object
  ? { [K in keyof T]: DeepNonNullable<NonNullable<T[K]>> }
  : NonNullable<T>;

/**
 * Extracts the non-null type from a nullable type.
 */
export type NonNull<T> = T extends null | undefined ? never : T;

/**
 * Type for GraphQL connection edges.
 */
export interface Connection<T> {
  readonly edges: ReadonlyArray<Edge<T>>;
  readonly pageInfo: PageInfo;
  readonly totalCount?: number;
}

/**
 * Type for GraphQL connection edge.
 */
export interface Edge<T> {
  readonly node: T;
  readonly cursor: string;
}

/**
 * Type for GraphQL page info.
 */
export interface PageInfo {
  readonly hasNextPage: boolean;
  readonly hasPreviousPage: boolean;
  readonly startCursor?: string;
  readonly endCursor?: string;
}

/**
 * Helper to extract nodes from a connection.
 */
export function extractNodes<T>(connection: Connection<T>): T[] {
  return connection.edges.map((edge) => edge.node);
}

/**
 * Helper to flatten nested nullable fields.
 */
export function unwrapNullable<T>(value: T | null | undefined): T | undefined {
  return value ?? undefined;
}

// =============================================================================
// Strict Type Inference - Advanced Type Utilities
// =============================================================================

/**
 * DeepReadonly - Makes all nested properties readonly.
 * Useful for immutable result data from queries.
 */
export type DeepReadonly<T> = T extends (infer U)[]
  ? DeepReadonlyArray<U>
  : T extends object
    ? DeepReadonlyObject<T>
    : T;

type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>;
type DeepReadonlyObject<T> = { readonly [K in keyof T]: DeepReadonly<T[K]> };

/**
 * Exact type - Ensures no extra properties are passed.
 * Prevents typos and invalid field access.
 *
 * @example
 * ```typescript
 * type User = { id: string; name: string };
 * const user: Exact<User> = { id: '1', name: 'John', typo: 'x' };
 * //                                               ^^ Error!
 * ```
 */
export type Exact<T, U extends T = T> = T extends object
  ? U extends T
    ? { [K in keyof U]: K extends keyof T ? Exact<T[K], U[K]> : never }
    : T
  : T;

/**
 * StrictOmit - Like Omit but enforces that keys exist.
 */
export type StrictOmit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

/**
 * StrictPick - Like Pick but enforces that keys exist.
 */
export type StrictPick<T, K extends keyof T> = Pick<T, K>;

/**
 * RequireAtLeastOne - Requires at least one of the specified keys.
 */
export type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<
  T,
  Exclude<keyof T, Keys>
> &
  { [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>> }[Keys];

/**
 * RequireOnlyOne - Requires exactly one of the specified keys.
 */
export type RequireOnlyOne<T, Keys extends keyof T = keyof T> = Pick<
  T,
  Exclude<keyof T, Keys>
> &
  {
    [K in Keys]-?: Required<Pick<T, K>> &
      Partial<Record<Exclude<Keys, K>, undefined>>;
  }[Keys];

// =============================================================================
// Union Discrimination - Type-Safe Result Pattern
// =============================================================================

/**
 * Discriminated union helper for __typename.
 * Enables exhaustive type narrowing.
 *
 * @example
 * ```typescript
 * type UserResult =
 *   | Discriminated<'User', { id: string; name: string }>
 *   | Discriminated<'NotFoundError', { message: string }>;
 *
 * function handleResult(result: UserResult) {
 *   switch (result.__typename) {
 *     case 'User':
 *       console.log(result.name); // Typed!
 *       break;
 *     case 'NotFoundError':
 *       console.log(result.message); // Typed!
 *       break;
 *     default:
 *       assertNever(result); // Ensures exhaustive
 *   }
 * }
 * ```
 */
export type Discriminated<TTypename extends string, TFields> = {
  readonly __typename: TTypename;
} & TFields;

/**
 * Union type with __typename discrimination.
 * Use this for GraphQL union/interface results.
 */
export type DiscriminatedUnion<T extends { __typename: string }> = T;

/**
 * Extracts a specific member from a discriminated union.
 */
export type ExtractUnionMember<
  TUnion extends { __typename: string },
  TTypename extends TUnion['__typename'],
> = Extract<TUnion, { __typename: TTypename }>;

/**
 * Creates a type guard for a discriminated union member.
 */
export function isTypename<
  T extends { __typename: string },
  K extends T['__typename'],
>(typename: K) {
  return (value: T): value is Extract<T, { __typename: K }> =>
    value.__typename === typename;
}

/**
 * Asserts that a value is never reached (for exhaustive checks).
 */
export function assertNever(value: never, message?: string): never {
  throw new Error(message ?? `Unexpected value: ${JSON.stringify(value)}`);
}

/**
 * Match expression for discriminated unions.
 * Provides exhaustive pattern matching.
 *
 * @example
 * ```typescript
 * const result: UserResult = await client.getUser({ id: '1' });
 *
 * const message = matchUnion(result, {
 *   User: (user) => `Hello, ${user.name}!`,
 *   NotFoundError: (err) => `Error: ${err.message}`,
 *   ValidationError: (err) => `Invalid: ${err.field}`,
 * });
 * ```
 */
export function matchUnion<
  T extends { __typename: string },
  R,
  Handlers extends { [K in T['__typename']]: (value: Extract<T, { __typename: K }>) => R },
>(value: T, handlers: Handlers): R {
  const handler = handlers[value.__typename as keyof Handlers];
  if (!handler) {
    throw new Error(`No handler for type: ${value.__typename}`);
  }
  return handler(value as never);
}

/**
 * Partial match with fallback.
 */
export function matchUnionPartial<
  T extends { __typename: string },
  R,
  Handlers extends Partial<{ [K in T['__typename']]: (value: Extract<T, { __typename: K }>) => R }>,
>(value: T, handlers: Handlers, fallback: (value: T) => R): R {
  const handler = handlers[value.__typename as keyof Handlers];
  if (handler) {
    return handler(value as never);
  }
  return fallback(value);
}

// =============================================================================
// Result Type Pattern - Type-Safe Error Handling
// =============================================================================

/**
 * Success result wrapper.
 */
export interface Success<T> {
  readonly ok: true;
  readonly value: T;
  readonly error?: undefined;
}

/**
 * Failure result wrapper.
 */
export interface Failure<E> {
  readonly ok: false;
  readonly value?: undefined;
  readonly error: E;
}

/**
 * Result type for type-safe error handling.
 */
export type Result<T, E = Error> = Success<T> | Failure<E>;

/**
 * Creates a success result.
 */
export function ok<T>(value: T): Success<T> {
  return { ok: true, value };
}

/**
 * Creates a failure result.
 */
export function err<E>(error: E): Failure<E> {
  return { ok: false, error };
}

/**
 * Checks if a result is a success.
 */
export function isOk<T, E>(result: Result<T, E>): result is Success<T> {
  return result.ok;
}

/**
 * Checks if a result is a failure.
 */
export function isErr<T, E>(result: Result<T, E>): result is Failure<E> {
  return !result.ok;
}

/**
 * Maps a successful result.
 */
export function mapResult<T, U, E>(
  result: Result<T, E>,
  fn: (value: T) => U
): Result<U, E> {
  return result.ok ? ok(fn(result.value)) : result;
}

/**
 * Maps an error result.
 */
export function mapError<T, E, F>(
  result: Result<T, E>,
  fn: (error: E) => F
): Result<T, F> {
  return result.ok ? result : err(fn(result.error));
}

/**
 * Unwraps a result, throwing on error.
 */
export function unwrap<T, E>(result: Result<T, E>): T {
  if (result.ok) return result.value;
  throw result.error instanceof Error ? result.error : new Error(String(result.error));
}

/**
 * Unwraps a result with a default value on error.
 */
export function unwrapOr<T, E>(result: Result<T, E>, defaultValue: T): T {
  return result.ok ? result.value : defaultValue;
}

// =============================================================================
// Operation Types - Strict Query/Mutation Typing
// =============================================================================

/**
 * Query operation marker type.
 */
export interface QueryOperation<TData, TVariables> extends TypedDocumentNode<TData, TVariables> {
  readonly __operationType: 'query';
}

/**
 * Mutation operation marker type.
 */
export interface MutationOperation<TData, TVariables> extends TypedDocumentNode<TData, TVariables> {
  readonly __operationType: 'mutation';
}

/**
 * Subscription operation marker type.
 */
export interface SubscriptionOperation<TData, TVariables> extends TypedDocumentNode<TData, TVariables> {
  readonly __operationType: 'subscription';
}

/**
 * Any operation type.
 */
export type AnyOperation<TData = unknown, TVariables = unknown> =
  | QueryOperation<TData, TVariables>
  | MutationOperation<TData, TVariables>
  | SubscriptionOperation<TData, TVariables>;

/**
 * Infers the operation type from a document.
 */
export type OperationTypeOf<T> = T extends { __operationType: infer O } ? O : never;

// =============================================================================
// Fragment Types - Type-Safe Fragment Usage
// =============================================================================

/**
 * Fragment definition with type information.
 */
export interface FragmentDefinition<TData, TTypename extends string = string> {
  readonly __fragmentType: TTypename;
  readonly __fragmentData?: TData;
}

/**
 * Extracts data type from a fragment definition.
 */
export type FragmentDataOf<T> = T extends FragmentDefinition<infer TData, string>
  ? TData
  : never;

/**
 * Makes a type require a fragment's fields.
 */
export type WithFragment<T, F extends FragmentDefinition<unknown>> = T &
  FragmentDataOf<F>;

/**
 * Creates a fragment ref for type-safe fragment spreading.
 */
export type FragmentRef<TData> = {
  readonly ' $fragmentData'?: TData;
};

/**
 * Masks fragment data (for data masking).
 */
export type MaskedFragment<T> = {
  readonly ' $fragmentData': T;
};

/**
 * Unmasks a masked fragment.
 */
export function unmask<T>(fragment: MaskedFragment<T>): T {
  return fragment as unknown as T;
}

// =============================================================================
// Scalar Types - Custom Scalar Mapping
// =============================================================================

/**
 * Default scalar type mapping.
 */
export interface ScalarTypes {
  ID: string;
  String: string;
  Int: number;
  Float: number;
  Boolean: boolean;
  DateTime: string;
  Date: string;
  Time: string;
  JSON: unknown;
  UUID: string;
  BigInt: bigint | string;
  Decimal: string;
  URL: string;
  Email: string;
}

/**
 * Resolves a scalar type name to its TypeScript type.
 */
export type ResolveScalar<T extends keyof ScalarTypes> = ScalarTypes[T];

/**
 * Allows customizing scalar types per-project.
 */
export interface CustomScalars {}

/**
 * Merged scalar types (custom overrides default).
 */
export type MergedScalars = CustomScalars & ScalarTypes;

// =============================================================================
// Input Types - Strict Input Validation
// =============================================================================

/**
 * NoExcessProperties - Prevents extra properties on input types.
 * Useful for catching typos in variables.
 */
export type NoExcessProperties<T, U extends T> = U & {
  [K in Exclude<keyof U, keyof T>]: never;
};

/**
 * Strict input type - requires all non-optional fields.
 */
export type StrictInput<T> = {
  [K in keyof T as undefined extends T[K] ? never : K]-?: T[K];
} & {
  [K in keyof T as undefined extends T[K] ? K : never]?: T[K];
};

/**
 * Input type with explicit undefined for optional fields.
 */
export type ExplicitOptional<T> = {
  [K in keyof T]: T[K] | undefined;
};

// =============================================================================
// Inference Helpers - Extract Types from Operations
// =============================================================================

/**
 * Extracts the return type of a query field.
 */
export type QueryFieldResult<
  TQuery extends TypedDocumentNode<unknown, unknown>,
  TField extends keyof NonNullable<ResultOf<TQuery>>,
> = NonNullable<ResultOf<TQuery>>[TField];

/**
 * Extracts a deeply nested field type.
 */
export type DeepFieldResult<T, K extends string> = K extends `${infer First}.${infer Rest}`
  ? First extends keyof T
    ? DeepFieldResult<NonNullable<T[First]>, Rest>
    : never
  : K extends keyof T
    ? T[K]
    : never;

/**
 * Makes array fields non-null in the result.
 */
export type NonNullableArrayElements<T> = T extends (infer U)[]
  ? NonNullable<U>[]
  : T;

/**
 * Unwraps connection type to array of nodes.
 */
export type UnwrapConnection<T> = T extends Connection<infer U> ? U[] : T;
