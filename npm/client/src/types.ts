/**
 * Core types for the bgql client.
 */

// =============================================================================
// TypedDocumentNode - Full Type Inference Support
// =============================================================================

/**
 * A typed document node that preserves the data and variables types.
 * This enables full type inference when executing GraphQL operations.
 *
 * @example
 * ```typescript
 * // Generated by bgql codegen
 * const GetUserDocument: TypedDocumentNode<
 *   { user: { id: string; name: string } },
 *   { id: string }
 * > = gql`
 *   query GetUser($id: ID!) {
 *     user(id: $id) {
 *       id
 *       name
 *     }
 *   }
 * `;
 *
 * // Full type inference
 * const result = await client.executeTyped(GetUserDocument, { id: '1' });
 * // result.value is typed as { user: { id: string; name: string } }
 * ```
 */
export interface TypedDocumentNode<TData = unknown, TVariables = Record<string, unknown>> {
  /** Phantom property to hold the data type */
  readonly __resultType?: TData;
  /** Phantom property to hold the variables type */
  readonly __variablesType?: TVariables;
  /** Metadata about the document */
  readonly __meta?: {
    readonly operationName: string;
    readonly operationType: 'query' | 'mutation' | 'subscription';
    readonly source: string;
  };
}

/**
 * Extracts the data type from a TypedDocumentNode.
 */
export type ResultOf<T> = T extends TypedDocumentNode<infer TData, unknown> ? TData : never;

/**
 * Extracts the variables type from a TypedDocumentNode.
 */
export type VariablesOf<T> = T extends TypedDocumentNode<unknown, infer TVariables> ? TVariables : never;

/**
 * Configuration options for creating a bgql client.
 */
export interface ClientConfig {
  /**
   * The GraphQL endpoint URL.
   */
  readonly url: string;

  /**
   * Default headers to include in every request.
   */
  readonly headers?: Record<string, string>;

  /**
   * Timeout for requests in milliseconds.
   * @default 30000
   */
  readonly timeout?: number;

  /**
   * Fetch implementation to use.
   * @default globalThis.fetch
   */
  readonly fetch?: typeof fetch;

  /**
   * Retry configuration.
   */
  readonly retry?: RetryConfig;

  /**
   * Custom error handler for logging/reporting.
   */
  readonly onError?: (error: unknown) => void;

  /**
   * Credentials mode for fetch.
   * @default 'same-origin'
   */
  readonly credentials?: RequestCredentials;
}

/**
 * Retry configuration.
 */
export interface RetryConfig {
  /**
   * Maximum number of retries.
   * @default 3
   */
  readonly maxRetries?: number;

  /**
   * Initial delay between retries in milliseconds.
   * @default 1000
   */
  readonly initialDelayMs?: number;

  /**
   * Maximum delay between retries in milliseconds.
   * @default 30000
   */
  readonly maxDelayMs?: number;

  /**
   * Whether to use exponential backoff.
   * @default true
   */
  readonly exponentialBackoff?: boolean;

  /**
   * Custom retry condition.
   */
  readonly shouldRetry?: (error: unknown, attempt: number) => boolean;
}

/**
 * Options for a single operation request.
 */
export interface RequestOptions {
  /**
   * AbortSignal for cancellation.
   */
  readonly signal?: AbortSignal;

  /**
   * Additional headers for this request.
   */
  readonly headers?: Record<string, string>;

  /**
   * Timeout override for this request.
   */
  readonly timeout?: number;

  /**
   * Context passed to middleware.
   */
  readonly context?: Record<string, unknown>;
}

/**
 * A GraphQL operation (query, mutation, subscription).
 */
export interface Operation<TVariables, TData> {
  /**
   * The operation name.
   */
  readonly operationName: string;

  /**
   * The operation type.
   */
  readonly operationType: 'query' | 'mutation' | 'subscription';

  /**
   * The GraphQL document string.
   */
  readonly document: string;

  /**
   * Variables for the operation.
   */
  readonly variables?: TVariables;
}

/**
 * GraphQL response from the server.
 */
export interface GraphQLResponse<TData> {
  readonly data?: TData;
  readonly errors?: ReadonlyArray<GraphQLErrorResponse>;
  readonly extensions?: Record<string, unknown>;
}

/**
 * GraphQL error in the response.
 */
export interface GraphQLErrorResponse {
  readonly message: string;
  readonly locations?: ReadonlyArray<{ line: number; column: number }>;
  readonly path?: ReadonlyArray<string | number>;
  readonly extensions?: Record<string, unknown>;
}

/**
 * Partial data with deferred fields.
 */
export type PartialData<T> = {
  [K in keyof T]: T[K] extends object
    ? PartialData<T[K]> | Promise<T[K]>
    : T[K];
};

/**
 * Streaming result for @defer/@stream.
 */
export interface StreamingResult<TData> {
  /**
   * Initial data (may have deferred fields).
   */
  readonly data: PartialData<TData>;

  /**
   * Whether there are more chunks coming.
   */
  readonly hasNext: boolean;

  /**
   * Async iterator for incremental updates.
   */
  readonly incremental?: AsyncIterable<IncrementalUpdate<TData>>;
}

/**
 * Incremental update from @defer/@stream.
 */
export interface IncrementalUpdate<TData> {
  readonly path: ReadonlyArray<string | number>;
  readonly data: Partial<TData>;
  readonly hasNext: boolean;
}

/**
 * Subscription observable.
 */
export interface Subscription<TData> {
  /**
   * Subscribe to updates.
   */
  subscribe(handlers: {
    next: (data: TData) => void;
    error?: (error: unknown) => void;
    complete?: () => void;
  }): Unsubscribe;
}

/**
 * Function to unsubscribe from a subscription.
 */
export type Unsubscribe = () => void;

/**
 * Middleware function for request/response interception.
 */
export type Middleware = (
  operation: Operation<unknown, unknown>,
  options: RequestOptions,
  next: (
    operation: Operation<unknown, unknown>,
    options: RequestOptions
  ) => Promise<GraphQLResponse<unknown>>
) => Promise<GraphQLResponse<unknown>>;

/**
 * Generated client operation methods.
 * This is a placeholder - actual types are generated from schema.
 */
export interface GeneratedOperations {
  [key: string]: (
    variables?: unknown,
    options?: RequestOptions
  ) => Promise<unknown>;
}

// =============================================================================
// Branded Types for Type-Safe IDs
// =============================================================================

/**
 * Creates a branded type for nominal typing.
 *
 * @example
 * ```typescript
 * type UserId = Brand<string, 'UserId'>;
 * type PostId = Brand<string, 'PostId'>;
 *
 * const userId: UserId = 'user_123' as UserId;
 * const postId: PostId = 'post_456' as PostId;
 *
 * // Error: Type 'UserId' is not assignable to type 'PostId'
 * const wrong: PostId = userId;
 * ```
 */
export type Brand<T, B extends string> = T & { readonly __brand: B };

/**
 * Helper to create branded values.
 */
export function brand<T, B extends string>(value: T): Brand<T, B> {
  return value as Brand<T, B>;
}

/**
 * Extracts the base type from a branded type.
 */
export type Unbrand<T> = T extends Brand<infer U, string> ? U : T;

// =============================================================================
// Option Type (for Option<T> from schema)
// =============================================================================

/**
 * Represents an optional value.
 * Maps to Option<T> in bgql schema.
 */
export type Option<T> = T | null;

/**
 * Checks if an Option has a value.
 */
export function isSome<T>(option: Option<T>): option is T {
  return option !== null;
}

/**
 * Checks if an Option is empty.
 */
export function isNone<T>(option: Option<T>): option is null {
  return option === null;
}

/**
 * Maps an Option value.
 */
export function mapOption<T, U>(
  option: Option<T>,
  fn: (value: T) => U
): Option<U> {
  return option !== null ? fn(option) : null;
}

/**
 * Unwraps an Option with a default value.
 */
export function unwrapOption<T>(option: Option<T>, defaultValue: T): T {
  return option !== null ? option : defaultValue;
}

// =============================================================================
// Extended Client Configuration Types
// =============================================================================

/**
 * Extended client configuration with all optional features.
 */
export interface ExtendedClientConfig extends ClientConfig {
  /**
   * Enable request deduplication.
   * Same queries with same variables will share a single request.
   * @default false
   */
  readonly dedupe?: boolean;

  /**
   * Enable automatic query batching.
   * Multiple queries will be batched into a single HTTP request.
   * @default false
   */
  readonly batch?: boolean | BatchOptions;

  /**
   * Enable normalized caching.
   * Entities are cached by type and ID for efficient updates.
   * @default false
   */
  readonly cache?: boolean | CacheOptions;
}

/**
 * Options for automatic query batching.
 */
export interface BatchOptions {
  /**
   * Maximum number of operations per batch.
   * @default 10
   */
  readonly maxSize?: number;

  /**
   * Maximum time to wait before executing a batch (ms).
   * @default 10
   */
  readonly interval?: number;
}

/**
 * Options for caching.
 */
export interface CacheOptions {
  /**
   * Time-to-live for cache entries (ms).
   * @default 300000 (5 minutes)
   */
  readonly ttl?: number;

  /**
   * Use normalized cache (entities by type/id).
   * @default true
   */
  readonly normalized?: boolean;
}

// =============================================================================
// Utility Types for Query Results
// =============================================================================

/**
 * Makes specified fields deeply partial.
 */
export type DeepPartial<T> = T extends object
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : T;

/**
 * Makes all fields non-nullable recursively.
 */
export type DeepNonNullable<T> = T extends object
  ? { [K in keyof T]: DeepNonNullable<NonNullable<T[K]>> }
  : NonNullable<T>;

/**
 * Extracts the non-null type from a nullable type.
 */
export type NonNull<T> = T extends null | undefined ? never : T;

/**
 * Type for GraphQL connection edges.
 */
export interface Connection<T> {
  readonly edges: ReadonlyArray<Edge<T>>;
  readonly pageInfo: PageInfo;
  readonly totalCount?: number;
}

/**
 * Type for GraphQL connection edge.
 */
export interface Edge<T> {
  readonly node: T;
  readonly cursor: string;
}

/**
 * Type for GraphQL page info.
 */
export interface PageInfo {
  readonly hasNextPage: boolean;
  readonly hasPreviousPage: boolean;
  readonly startCursor?: string;
  readonly endCursor?: string;
}

/**
 * Helper to extract nodes from a connection.
 */
export function extractNodes<T>(connection: Connection<T>): T[] {
  return connection.edges.map((edge) => edge.node);
}

/**
 * Helper to flatten nested nullable fields.
 */
export function unwrapNullable<T>(value: T | null | undefined): T | undefined {
  return value ?? undefined;
}
