//! Generated by Better GraphQL (bgql)
//! DO NOT EDIT - this file is auto-generated

#![allow(dead_code)]
#![allow(unused_imports)]

use async_trait::async_trait;
use bgql_sdk::server::Context;
use bgql_sdk::SdkResult;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;

// =============================================================================
// Opaque Types (Type-safe IDs)
// =============================================================================

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct UserId(pub String);

impl UserId {
    pub fn new(id: impl Into<String>) -> Self {
        Self(id.into())
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct PostId(pub String);

impl PostId {
    pub fn new(id: impl Into<String>) -> Self {
        Self(id.into())
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct CommentId(pub String);

impl CommentId {
    pub fn new(id: impl Into<String>) -> Self {
        Self(id.into())
    }
}

// =============================================================================
// Enums
// =============================================================================

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum PostStatus {
    Draft,
    Published,
    Archived,
}

impl PostStatus {
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "Draft" | "DRAFT" => Some(Self::Draft),
            "Published" | "PUBLISHED" => Some(Self::Published),
            "Archived" | "ARCHIVED" => Some(Self::Archived),
            _ => None,
        }
    }
}

impl std::fmt::Display for PostStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Draft => write!(f, "Draft"),
            Self::Published => write!(f, "Published"),
            Self::Archived => write!(f, "Archived"),
        }
    }
}

// =============================================================================
// Domain Types
// =============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: UserId,
    pub name: String,
    pub email: String,
    pub bio: Option<String>,
    #[serde(rename = "createdAt")]
    pub created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Post {
    pub id: PostId,
    pub title: String,
    pub content: String,
    pub status: PostStatus,
    #[serde(rename = "authorId")]
    pub author_id: UserId,
    #[serde(rename = "createdAt")]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "updatedAt")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Comment {
    pub id: CommentId,
    pub content: String,
    #[serde(rename = "postId")]
    pub post_id: PostId,
    #[serde(rename = "authorId")]
    pub author_id: UserId,
    #[serde(rename = "createdAt")]
    pub created_at: chrono::DateTime<chrono::Utc>,
}

// =============================================================================
// Input Types
// =============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreatePostInput {
    pub title: String,
    pub content: String,
    #[serde(default)]
    pub status: Option<PostStatus>,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct UpdatePostInput {
    #[serde(default)]
    pub title: Option<String>,
    #[serde(default)]
    pub content: Option<String>,
    #[serde(default)]
    pub status: Option<PostStatus>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateCommentInput {
    #[serde(rename = "postId")]
    pub post_id: PostId,
    pub content: String,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct PaginationInput {
    #[serde(default)]
    pub first: Option<i32>,
    #[serde(default)]
    pub after: Option<String>,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct PostFilter {
    #[serde(default)]
    pub status: Option<PostStatus>,
    #[serde(rename = "authorId", default)]
    pub author_id: Option<UserId>,
}

// =============================================================================
// Connection Types (Pagination)
// =============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Connection<T> {
    pub edges: Vec<Edge<T>>,
    #[serde(rename = "pageInfo")]
    pub page_info: PageInfo,
    #[serde(rename = "totalCount")]
    pub total_count: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Edge<T> {
    pub cursor: String,
    pub node: T,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageInfo {
    #[serde(rename = "hasNextPage")]
    pub has_next_page: bool,
    #[serde(rename = "hasPreviousPage")]
    pub has_previous_page: bool,
    #[serde(rename = "startCursor")]
    pub start_cursor: Option<String>,
    #[serde(rename = "endCursor")]
    pub end_cursor: Option<String>,
}

// =============================================================================
// Query Arguments
// =============================================================================

#[derive(Debug, Clone, Deserialize)]
pub struct UserArgs {
    pub id: UserId,
}

#[derive(Debug, Clone, Default, Deserialize)]
pub struct UsersArgs {
    #[serde(default)]
    pub pagination: Option<PaginationInput>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct PostArgs {
    pub id: PostId,
}

#[derive(Debug, Clone, Default, Deserialize)]
pub struct PostsArgs {
    #[serde(default)]
    pub filter: Option<PostFilter>,
    #[serde(default)]
    pub pagination: Option<PaginationInput>,
}

// =============================================================================
// Mutation Arguments
// =============================================================================

#[derive(Debug, Clone, Deserialize)]
pub struct CreatePostArgs {
    pub input: CreatePostInput,
}

#[derive(Debug, Clone, Deserialize)]
pub struct UpdatePostArgs {
    pub id: PostId,
    pub input: UpdatePostInput,
}

#[derive(Debug, Clone, Deserialize)]
pub struct PublishPostArgs {
    pub id: PostId,
}

#[derive(Debug, Clone, Deserialize)]
pub struct DeletePostArgs {
    pub id: PostId,
}

#[derive(Debug, Clone, Deserialize)]
pub struct CreateCommentArgs {
    pub input: CreateCommentInput,
}

// =============================================================================
// Resolver Traits
// =============================================================================

/// Query resolvers trait.
#[async_trait]
pub trait QueryResolvers: Send + Sync + 'static {
    async fn user(&self, ctx: &Context, args: UserArgs) -> SdkResult<serde_json::Value>;
    async fn users(&self, ctx: &Context, args: UsersArgs) -> SdkResult<serde_json::Value>;
    async fn post(&self, ctx: &Context, args: PostArgs) -> SdkResult<serde_json::Value>;
    async fn posts(&self, ctx: &Context, args: PostsArgs) -> SdkResult<serde_json::Value>;
}

/// Mutation resolvers trait.
#[async_trait]
pub trait MutationResolvers: Send + Sync + 'static {
    async fn create_post(
        &self,
        ctx: &Context,
        args: CreatePostArgs,
    ) -> SdkResult<serde_json::Value>;
    async fn update_post(
        &self,
        ctx: &Context,
        args: UpdatePostArgs,
    ) -> SdkResult<serde_json::Value>;
    async fn publish_post(
        &self,
        ctx: &Context,
        args: PublishPostArgs,
    ) -> SdkResult<serde_json::Value>;
    async fn delete_post(
        &self,
        ctx: &Context,
        args: DeletePostArgs,
    ) -> SdkResult<serde_json::Value>;
    async fn create_comment(
        &self,
        ctx: &Context,
        args: CreateCommentArgs,
    ) -> SdkResult<serde_json::Value>;
}

// =============================================================================
// Server Builder Extension
// =============================================================================

/// Extension trait for type-safe resolver registration.
pub trait ServerBuilderExt {
    fn query_resolvers(self, resolvers: Arc<dyn QueryResolvers>) -> Self;
    fn mutation_resolvers(self, resolvers: Arc<dyn MutationResolvers>) -> Self;
}

fn parse_args<T: for<'de> serde::Deserialize<'de>>(
    args: serde_json::Value,
) -> SdkResult<T> {
    serde_json::from_value(args).map_err(|e| {
        bgql_sdk::SdkError::new(bgql_sdk::ErrorCode::DeserializeError, e.to_string())
    })
}

impl ServerBuilderExt for bgql_sdk::server::ServerBuilder {
    fn query_resolvers(mut self, resolvers: Arc<dyn QueryResolvers>) -> Self {
        let r = resolvers.clone();
        self = self.resolver("Query", "user", move |args, ctx| {
            let r = r.clone();
            async move {
                let parsed: UserArgs = parse_args(args)?;
                r.user(&ctx, parsed).await
            }
        });

        let r = resolvers.clone();
        self = self.resolver("Query", "users", move |args, ctx| {
            let r = r.clone();
            async move {
                let parsed: UsersArgs = serde_json::from_value(args).unwrap_or_default();
                r.users(&ctx, parsed).await
            }
        });

        let r = resolvers.clone();
        self = self.resolver("Query", "post", move |args, ctx| {
            let r = r.clone();
            async move {
                let parsed: PostArgs = parse_args(args)?;
                r.post(&ctx, parsed).await
            }
        });

        let r = resolvers.clone();
        self = self.resolver("Query", "posts", move |args, ctx| {
            let r = r.clone();
            async move {
                let parsed: PostsArgs = serde_json::from_value(args).unwrap_or_default();
                r.posts(&ctx, parsed).await
            }
        });

        self
    }

    fn mutation_resolvers(mut self, resolvers: Arc<dyn MutationResolvers>) -> Self {
        let r = resolvers.clone();
        self = self.resolver("Mutation", "createPost", move |args, ctx| {
            let r = r.clone();
            async move {
                let parsed: CreatePostArgs = parse_args(args)?;
                r.create_post(&ctx, parsed).await
            }
        });

        let r = resolvers.clone();
        self = self.resolver("Mutation", "updatePost", move |args, ctx| {
            let r = r.clone();
            async move {
                let parsed: UpdatePostArgs = parse_args(args)?;
                r.update_post(&ctx, parsed).await
            }
        });

        let r = resolvers.clone();
        self = self.resolver("Mutation", "publishPost", move |args, ctx| {
            let r = r.clone();
            async move {
                let parsed: PublishPostArgs = parse_args(args)?;
                r.publish_post(&ctx, parsed).await
            }
        });

        let r = resolvers.clone();
        self = self.resolver("Mutation", "deletePost", move |args, ctx| {
            let r = r.clone();
            async move {
                let parsed: DeletePostArgs = parse_args(args)?;
                r.delete_post(&ctx, parsed).await
            }
        });

        let r = resolvers.clone();
        self = self.resolver("Mutation", "createComment", move |args, ctx| {
            let r = r.clone();
            async move {
                let parsed: CreateCommentArgs = parse_args(args)?;
                r.create_comment(&ctx, parsed).await
            }
        });

        self
    }
}
