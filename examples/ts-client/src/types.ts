/**
 * Type definitions for the BGQL client example.
 *
 * In production, these would be generated by:
 *   bgql generate --schema ../schema.bgql --output ./src/generated --target client
 */

// Branded types for compile-time ID safety
export type UserId = string & { readonly __brand: "UserId" };
export type PostId = string & { readonly __brand: "PostId" };

// Helper functions
export const UserId = (id: string): UserId => id as UserId;
export const PostId = (id: string): PostId => id as PostId;

// Enums
export type UserRole = "Admin" | "Moderator" | "User" | "Guest";
export type PostStatus = "Draft" | "Published" | "Archived";

// Object types (readonly for immutability)
export interface User {
  readonly __typename: "User";
  readonly id: UserId;
  readonly name: string;
  readonly email: string;
  readonly bio: string | null;
  readonly avatarUrl: string | null;
  readonly role: UserRole;
  readonly createdAt: string;
  readonly updatedAt: string | null;
}

export interface Post {
  readonly __typename: "Post";
  readonly id: PostId;
  readonly title: string;
  readonly content: string;
  readonly authorId: UserId;
  readonly status: PostStatus;
  readonly publishedAt: string | null;
  readonly createdAt: string;
}

export interface UserAnalytics {
  readonly totalPosts: number;
  readonly totalComments: number;
  readonly totalLikes: number;
}

// Error types (all readonly)
export interface NotFoundError {
  readonly __typename: "NotFoundError";
  readonly message: string;
  readonly code: string;
  readonly resourceType: string;
  readonly resourceId: string;
}

export interface ValidationError {
  readonly __typename: "ValidationError";
  readonly message: string;
  readonly code: string;
  readonly field: string;
  readonly constraint: string;
}

export interface UnauthorizedError {
  readonly __typename: "UnauthorizedError";
  readonly message: string;
  readonly code: string;
  readonly requiredRole: UserRole | null;
}

export interface InvalidCredentialsError {
  readonly __typename: "InvalidCredentialsError";
  readonly message: string;
  readonly code: string;
}

// Result unions (discriminated by __typename)
export type UserResult = User | NotFoundError | UnauthorizedError;
export type CreateUserResult = User | ValidationError;
export type CreatePostResult = Post | ValidationError | UnauthorizedError;

export interface AuthPayload {
  readonly __typename: "AuthPayload";
  readonly token: string;
  readonly user: Omit<User, "__typename">;
  readonly expiresAt: string;
}

export type AuthResult = AuthPayload | InvalidCredentialsError | ValidationError;

// Connection types
export interface PageInfo {
  readonly hasNextPage: boolean;
  readonly hasPreviousPage: boolean;
  readonly startCursor: string | null;
  readonly endCursor: string | null;
}

export interface Edge<T> {
  readonly node: T;
  readonly cursor: string;
}

export interface Connection<T> {
  readonly edges: readonly Edge<T>[];
  readonly pageInfo: PageInfo;
  readonly totalCount: number;
}

// Input types
export interface CreateUserInput {
  readonly name: string;
  readonly email: string;
  readonly password: string;
  readonly bio?: string | null;
}

export interface CreatePostInput {
  readonly title: string;
  readonly content: string;
  readonly status?: PostStatus;
}

export interface EmailCredentials {
  readonly email: string;
  readonly password: string;
}

export interface OAuthCredentials {
  readonly provider: "Google" | "GitHub" | "Apple";
  readonly token: string;
}

export type LoginCredentials = EmailCredentials | OAuthCredentials;
