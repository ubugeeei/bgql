//! Go code generator.

use crate::{extract_types, CodegenOptions, TypeConverter};
use bgql_core::Interner;
use bgql_syntax::{Document, FieldDefinition, InputValueDefinition, Type, TypeDefinition};

/// Go code generator.
pub struct GoGenerator<'a> {
    document: &'a Document<'a>,
    interner: &'a Interner,
    options: &'a CodegenOptions,
    output: String,
}

impl<'a> GoGenerator<'a> {
    pub fn new(
        document: &'a Document<'a>,
        interner: &'a Interner,
        options: &'a CodegenOptions,
    ) -> Self {
        Self {
            document,
            interner,
            options,
            output: String::new(),
        }
    }

    pub fn generate(mut self) -> String {
        self.write_header();
        self.write_imports();
        self.write_types();

        if self.options.client {
            self.write_client_sdk();
        }

        if self.options.server {
            self.write_server_sdk();
        }

        self.output
    }

    fn write_header(&mut self) {
        self.output
            .push_str("// Code generated by Better GraphQL (bgql). DO NOT EDIT.\n\n");
        self.output
            .push_str(&format!("package {}\n\n", self.options.package_name));
    }

    fn write_imports(&mut self) {
        self.output.push_str("import (\n");
        self.output.push_str("\t\"context\"\n");
        self.output.push_str("\t\"encoding/json\"\n");
        if self.options.client {
            self.output.push_str("\t\"fmt\"\n");
        }
        self.output.push_str(")\n\n");
    }

    fn write_types(&mut self) {
        self.output.push_str(
            "// =============================================================================\n",
        );
        self.output.push_str("// Types\n");
        self.output.push_str(
            "// =============================================================================\n\n",
        );

        for type_def in extract_types(self.document) {
            match type_def {
                TypeDefinition::Object(obj) => self.write_struct(obj),
                TypeDefinition::Interface(iface) => self.write_interface(iface),
                TypeDefinition::Enum(e) => self.write_enum(e),
                TypeDefinition::Union(u) => self.write_union(u),
                TypeDefinition::Input(inp) => self.write_input(inp),
                TypeDefinition::Scalar(s) => self.write_scalar(s),
                TypeDefinition::Opaque(o) => self.write_newtype(o),
                TypeDefinition::TypeAlias(a) => self.write_type_alias(a),
                TypeDefinition::InputUnion(iu) => self.write_input_union(iu),
            }
        }
    }

    fn write_struct(&mut self, obj: &bgql_syntax::ObjectTypeDefinition<'_>) {
        let name = self.interner.get(obj.name.value);

        if let Some(desc) = &obj.description {
            self.output.push_str(&format!(
                "// {} {}\n",
                name,
                desc.value.replace('\n', "\n// ")
            ));
        }

        self.output.push_str(&format!("type {} struct {{\n", name));

        for field in &obj.fields {
            self.write_struct_field(field);
        }

        self.output.push_str("}\n\n");
    }

    fn write_interface(&mut self, iface: &bgql_syntax::InterfaceTypeDefinition<'_>) {
        let name = self.interner.get(iface.name.value);

        if let Some(desc) = &iface.description {
            self.output.push_str(&format!(
                "// {} {}\n",
                name,
                desc.value.replace('\n', "\n// ")
            ));
        }

        self.output
            .push_str(&format!("type {} interface {{\n", name));

        for field in &iface.fields {
            let field_name = self.interner.get(field.name.value);
            let go_type = self.convert_type(&field.ty, self.interner);
            self.output
                .push_str(&format!("\t{}() {}\n", capitalize(&field_name), go_type));
        }

        self.output.push_str("}\n\n");
    }

    fn write_enum(&mut self, e: &bgql_syntax::EnumTypeDefinition<'_>) {
        let name = self.interner.get(e.name.value);

        if let Some(desc) = &e.description {
            self.output.push_str(&format!(
                "// {} {}\n",
                name,
                desc.value.replace('\n', "\n// ")
            ));
        }

        // Check if any values have data
        let has_data = e.values.iter().any(|v| v.data.is_some());

        if has_data {
            // Complex enum with data - use interface pattern
            self.output
                .push_str(&format!("type {} interface {{\n", name));
            self.output.push_str(&format!("\tis{}()\n", name));
            self.output.push_str("}\n\n");

            for value in &e.values {
                let variant_name = self.interner.get(value.name.value);
                let full_name = format!("{}_{}", name, variant_name);

                match &value.data {
                    Some(bgql_syntax::EnumVariantData::Tuple(types, _)) => {
                        self.output
                            .push_str(&format!("type {} struct {{\n", full_name));
                        for (i, ty) in types.iter().enumerate() {
                            let go_type = self.convert_type(ty, self.interner);
                            self.output.push_str(&format!("\tField{} {}\n", i, go_type));
                        }
                        self.output.push_str("}\n\n");
                    }
                    Some(bgql_syntax::EnumVariantData::Struct(fields, _)) => {
                        self.output
                            .push_str(&format!("type {} struct {{\n", full_name));
                        for field in fields {
                            let field_name = self.interner.get(field.name.value);
                            let go_type = self.convert_type(&field.ty, self.interner);
                            self.output.push_str(&format!(
                                "\t{} {} `json:\"{}\"`\n",
                                capitalize(&field_name),
                                go_type,
                                field_name
                            ));
                        }
                        self.output.push_str("}\n\n");
                    }
                    None => {
                        self.output
                            .push_str(&format!("type {} struct{{}}\n\n", full_name));
                    }
                }

                // Implement the interface
                self.output
                    .push_str(&format!("func ({}) is{}() {{}}\n\n", full_name, name));
            }
        } else {
            // Simple enum - use string type with constants
            self.output.push_str(&format!("type {} string\n\n", name));
            self.output.push_str("const (\n");

            for value in &e.values {
                let val = self.interner.get(value.name.value);
                self.output
                    .push_str(&format!("\t{}_{} {} = \"{}\"\n", name, val, name, val));
            }

            self.output.push_str(")\n\n");
        }
    }

    fn write_union(&mut self, u: &bgql_syntax::UnionTypeDefinition<'_>) {
        let name = self.interner.get(u.name.value);

        if let Some(desc) = &u.description {
            self.output.push_str(&format!(
                "// {} {}\n",
                name,
                desc.value.replace('\n', "\n// ")
            ));
        }

        // In Go, unions are represented as interfaces
        self.output
            .push_str(&format!("type {} interface {{\n", name));
        self.output.push_str(&format!("\tis{}()\n", name));
        self.output.push_str("}\n\n");

        // Implement the interface for each member
        for member in &u.members {
            let member_name = self.interner.get(member.value);
            self.output
                .push_str(&format!("func ({}) is{}() {{}}\n\n", member_name, name));
        }
    }

    fn write_input(&mut self, inp: &bgql_syntax::InputObjectTypeDefinition<'_>) {
        let name = self.interner.get(inp.name.value);

        if let Some(desc) = &inp.description {
            self.output.push_str(&format!(
                "// {} {}\n",
                name,
                desc.value.replace('\n', "\n// ")
            ));
        }

        self.output.push_str(&format!("type {} struct {{\n", name));

        for field in &inp.fields {
            self.write_input_field(field);
        }

        self.output.push_str("}\n\n");
    }

    fn write_scalar(&mut self, s: &bgql_syntax::ScalarTypeDefinition<'_>) {
        let name = self.interner.get(s.name.value);

        if let Some(desc) = &s.description {
            self.output.push_str(&format!(
                "// {} {}\n",
                name,
                desc.value.replace('\n', "\n// ")
            ));
        }

        // Custom scalars map to interface{}
        self.output
            .push_str(&format!("type {} = interface{{}}\n\n", name));
    }

    fn write_newtype(&mut self, o: &bgql_syntax::OpaqueTypeDefinition<'_>) {
        let name = self.interner.get(o.name.value);
        let underlying = self.convert_type(&o.underlying, self.interner);

        if let Some(desc) = &o.description {
            self.output.push_str(&format!(
                "// {} {}\n",
                name,
                desc.value.replace('\n', "\n// ")
            ));
        }

        self.output
            .push_str(&format!("type {} {}\n\n", name, underlying));
    }

    fn write_type_alias(&mut self, a: &bgql_syntax::TypeAliasDefinition<'_>) {
        let name = self.interner.get(a.name.value);
        let aliased = self.convert_type(&a.aliased, self.interner);

        if let Some(desc) = &a.description {
            self.output.push_str(&format!(
                "// {} {}\n",
                name,
                desc.value.replace('\n', "\n// ")
            ));
        }

        self.output
            .push_str(&format!("type {} = {}\n\n", name, aliased));
    }

    fn write_input_union(&mut self, iu: &bgql_syntax::InputUnionTypeDefinition<'_>) {
        let name = self.interner.get(iu.name.value);

        if let Some(desc) = &iu.description {
            self.output.push_str(&format!(
                "// {} {}\n",
                name,
                desc.value.replace('\n', "\n// ")
            ));
        }

        self.output
            .push_str(&format!("type {} interface {{\n", name));
        self.output.push_str(&format!("\tis{}Input()\n", name));
        self.output.push_str("}\n\n");
    }

    fn write_struct_field(&mut self, field: &FieldDefinition<'_>) {
        let name = self.interner.get(field.name.value);
        let go_type = self.convert_type(&field.ty, self.interner);

        if let Some(desc) = &field.description {
            self.output.push_str(&format!("\t// {}\n", desc.value));
        }

        self.output.push_str(&format!(
            "\t{} {} `json:\"{}\"`\n",
            capitalize(&name),
            go_type,
            name
        ));
    }

    fn write_input_field(&mut self, field: &InputValueDefinition<'_>) {
        let name = self.interner.get(field.name.value);
        let go_type = self.convert_type(&field.ty, self.interner);
        let is_optional = matches!(&field.ty, Type::Option(_, _));

        if let Some(desc) = &field.description {
            self.output.push_str(&format!("\t// {}\n", desc.value));
        }

        let json_tag = if is_optional {
            format!("`json:\"{},omitempty\"`", name)
        } else {
            format!("`json:\"{}\"`", name)
        };

        self.output.push_str(&format!(
            "\t{} {} {}\n",
            capitalize(&name),
            go_type,
            json_tag
        ));
    }

    fn write_client_sdk(&mut self) {
        self.output.push_str(
            "// =============================================================================\n",
        );
        self.output.push_str("// Client SDK\n");
        self.output.push_str(
            "// =============================================================================\n\n",
        );

        // Collect method info first to avoid borrow conflicts
        let query_methods = self.collect_client_methods("Query");
        let mutation_methods = self.collect_client_methods("Mutation");

        // Generate client interface
        self.output
            .push_str("// GraphQLClient is the interface for making typed GraphQL requests.\n");
        self.output.push_str("type GraphQLClient interface {\n");

        for (name, args, return_type) in &query_methods {
            self.output
                .push_str(&format!("\t{}({}) ({}, error)\n", name, args, return_type));
        }

        for (name, args, return_type) in &mutation_methods {
            self.output
                .push_str(&format!("\t{}({}) ({}, error)\n", name, args, return_type));
        }

        self.output.push_str("}\n\n");
    }

    fn collect_client_methods(&self, type_name: &str) -> Vec<(String, String, String)> {
        let type_def = extract_types(self.document).into_iter().find(|t| {
            if let TypeDefinition::Object(obj) = t {
                self.interner.get(obj.name.value) == type_name
            } else {
                false
            }
        });

        let Some(TypeDefinition::Object(obj)) = type_def else {
            return Vec::new();
        };

        obj.fields
            .iter()
            .map(|field| {
                let name = capitalize(&self.interner.get(field.name.value));
                let return_type = self.convert_type(&field.ty, self.interner);

                let args = if field.arguments.is_empty() {
                    "ctx context.Context".to_string()
                } else {
                    let arg_list: Vec<_> = field
                        .arguments
                        .iter()
                        .map(|arg| {
                            let arg_name = self.interner.get(arg.name.value);
                            let arg_type = self.convert_type(&arg.ty, self.interner);
                            format!("{} {}", to_camel_case(&arg_name), arg_type)
                        })
                        .collect();
                    format!("ctx context.Context, {}", arg_list.join(", "))
                };

                (name, args, return_type)
            })
            .collect()
    }

    fn write_server_sdk(&mut self) {
        self.output.push_str(
            "// =============================================================================\n",
        );
        self.output.push_str("// Server SDK (Resolvers)\n");
        self.output.push_str(
            "// =============================================================================\n\n",
        );

        // Generate resolver interfaces
        for type_def in extract_types(self.document) {
            if let TypeDefinition::Object(obj) = type_def {
                let name = self.interner.get(obj.name.value);
                if name == "Query" || name == "Mutation" {
                    self.write_resolver_interface(obj, &name);
                }
            }
        }
    }

    fn write_resolver_interface(
        &mut self,
        obj: &bgql_syntax::ObjectTypeDefinition<'_>,
        type_name: &str,
    ) {
        self.output.push_str(&format!(
            "// {}Resolvers defines the resolver interface for {} fields.\n",
            type_name, type_name
        ));
        self.output
            .push_str(&format!("type {}Resolvers interface {{\n", type_name));

        for field in &obj.fields {
            let name = self.interner.get(field.name.value);
            let return_type = self.convert_type(&field.ty, self.interner);

            let args = if field.arguments.is_empty() {
                "ctx context.Context".to_string()
            } else {
                let arg_list: Vec<_> = field
                    .arguments
                    .iter()
                    .map(|arg| {
                        let arg_name = self.interner.get(arg.name.value);
                        let arg_type = self.convert_type(&arg.ty, self.interner);
                        format!("{} {}", to_camel_case(&arg_name), arg_type)
                    })
                    .collect();
                format!("ctx context.Context, {}", arg_list.join(", "))
            };

            self.output.push_str(&format!(
                "\tResolve{}({}) ({}, error)\n",
                capitalize(&name),
                args,
                return_type
            ));
        }

        self.output.push_str("}\n\n");
    }
}

impl<'a> TypeConverter for GoGenerator<'a> {
    fn convert_type(&self, ty: &Type<'_>, interner: &Interner) -> String {
        match ty {
            Type::Named(named) => {
                let name = interner.get(named.name);
                self.convert_scalar(&name)
            }
            Type::Option(inner, _) => {
                format!("*{}", self.convert_type(inner, interner))
            }
            Type::List(inner, _) => {
                format!("[]{}", self.convert_type(inner, interner))
            }
            Type::Generic(_) => {
                // Go doesn't have generics like this, use interface{}
                "interface{}".to_string()
            }
            Type::Tuple(_) => {
                // Go doesn't have tuples, use a struct or slice
                "interface{}".to_string()
            }
            Type::_Phantom(_) => "interface{}".to_string(),
        }
    }

    fn convert_scalar(&self, name: &str) -> String {
        match name {
            "Int" => "int".to_string(),
            "Float" => "float64".to_string(),
            "String" => "string".to_string(),
            "ID" => "string".to_string(),
            "Boolean" => "bool".to_string(),
            "DateTime" => "string".to_string(),
            "JSON" => "map[string]interface{}".to_string(),
            other => other.to_string(),
        }
    }
}

fn capitalize(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(f) => f.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

fn to_camel_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = false;

    for (i, c) in s.chars().enumerate() {
        if c == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_uppercase().next().unwrap());
            capitalize_next = false;
        } else if i == 0 {
            result.push(c.to_lowercase().next().unwrap());
        } else {
            result.push(c);
        }
    }

    result
}
