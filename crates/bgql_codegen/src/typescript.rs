//! TypeScript code generator.

use crate::{extract_types, CodegenOptions, TypeConverter};
use bgql_core::Interner;
use bgql_syntax::{Document, FieldDefinition, InputValueDefinition, Type, TypeDefinition};

/// TypeScript code generator.
pub struct TypeScriptGenerator<'a> {
    document: &'a Document<'a>,
    interner: &'a Interner,
    options: &'a CodegenOptions,
    output: String,
}

impl<'a> TypeScriptGenerator<'a> {
    pub fn new(
        document: &'a Document<'a>,
        interner: &'a Interner,
        options: &'a CodegenOptions,
    ) -> Self {
        Self {
            document,
            interner,
            options,
            output: String::new(),
        }
    }

    pub fn generate(mut self) -> String {
        self.write_header();
        self.write_imports();
        self.write_scalars();
        self.write_types();

        if self.options.client {
            self.write_client_sdk();
        }

        if self.options.server {
            self.write_server_sdk();
        }

        self.output
    }

    fn write_header(&mut self) {
        self.output.push_str("/**\n");
        self.output
            .push_str(" * Generated by Better GraphQL (bgql)\n");
        self.output
            .push_str(" * DO NOT EDIT - this file is auto-generated\n");
        self.output.push_str(" */\n\n");
        self.output.push_str("/* eslint-disable */\n");
        self.output.push_str("/* tslint:disable */\n\n");
    }

    fn write_imports(&mut self) {
        if self.options.include_runtime {
            self.output
                .push_str("import type { Result } from '@bgql/client';\n");
            self.output
                .push_str("import type { BgqlClient } from '@bgql/client';\n");
            if self.options.server {
                self.output.push_str(
                    "import type { BaseContext, ResolverFn, DataLoader } from '@bgql/server';\n",
                );
            }
            self.output.push('\n');
        }
    }

    fn write_scalars(&mut self) {
        self.output.push_str(
            "// =============================================================================\n",
        );
        self.output.push_str("// Scalars\n");
        self.output.push_str(
            "// =============================================================================\n\n",
        );
        self.output.push_str("export type ID = string;\n");
        self.output.push_str("export type Int = number;\n");
        self.output.push_str("export type Float = number;\n");
        self.output.push_str("export type Boolean = boolean;\n");
        self.output.push_str("export type String = string;\n");
        self.output.push_str("export type DateTime = string;\n");
        self.output
            .push_str("export type JSON = Record<string, unknown>;\n\n");
    }

    fn write_types(&mut self) {
        self.output.push_str(
            "// =============================================================================\n",
        );
        self.output.push_str("// Types\n");
        self.output.push_str(
            "// =============================================================================\n\n",
        );

        for type_def in extract_types(self.document) {
            match type_def {
                TypeDefinition::Object(obj) => self.write_object_type(obj),
                TypeDefinition::Interface(iface) => self.write_interface_type(iface),
                TypeDefinition::Enum(e) => self.write_enum_type(e),
                TypeDefinition::Union(u) => self.write_union_type(u),
                TypeDefinition::Input(inp) => self.write_input_type(inp),
                TypeDefinition::Scalar(s) => self.write_scalar_type(s),
                TypeDefinition::Opaque(o) => self.write_opaque_type(o),
                TypeDefinition::TypeAlias(a) => self.write_type_alias(a),
                TypeDefinition::InputUnion(iu) => self.write_input_union(iu),
            }
        }
    }

    fn write_object_type(&mut self, obj: &bgql_syntax::ObjectTypeDefinition<'_>) {
        let name = self.interner.get(obj.name.value);

        // Write description if present
        if let Some(desc) = &obj.description {
            self.write_jsdoc(desc.value);
        }

        // Write interface
        self.output.push_str(&format!("export interface {} ", name));

        // Handle implements
        if !obj.implements.is_empty() {
            let extends: Vec<_> = obj
                .implements
                .iter()
                .map(|i| self.interner.get(i.value))
                .collect();
            self.output
                .push_str(&format!("extends {} ", extends.join(", ")));
        }

        self.output.push_str("{\n");

        // Add __typename for union discrimination
        self.output
            .push_str(&format!("  readonly __typename?: '{}';\n", name));

        // Write fields
        for field in &obj.fields {
            self.write_field(field);
        }

        self.output.push_str("}\n\n");
    }

    fn write_interface_type(&mut self, iface: &bgql_syntax::InterfaceTypeDefinition<'_>) {
        let name = self.interner.get(iface.name.value);

        if let Some(desc) = &iface.description {
            self.write_jsdoc(desc.value);
        }

        self.output
            .push_str(&format!("export interface {} {{\n", name));

        for field in &iface.fields {
            self.write_field(field);
        }

        self.output.push_str("}\n\n");
    }

    fn write_enum_type(&mut self, e: &bgql_syntax::EnumTypeDefinition<'_>) {
        let name = self.interner.get(e.name.value);

        if let Some(desc) = &e.description {
            self.write_jsdoc(desc.value);
        }

        // Check if any values have data (Rust-style enum)
        let has_data = e.values.iter().any(|v| v.data.is_some());

        if has_data {
            // Generate discriminated union for Rust-style enums
            self.write_rust_style_enum(e);
        } else {
            // Simple string union
            let values: Vec<_> = e
                .values
                .iter()
                .map(|v| format!("'{}'", self.interner.get(v.name.value)))
                .collect();
            self.output.push_str(&format!(
                "export type {} = {};\n\n",
                name,
                values.join(" | ")
            ));

            // Also generate const object for runtime use
            self.output
                .push_str(&format!("export const {} = {{\n", name));
            for value in &e.values {
                let val = self.interner.get(value.name.value);
                self.output.push_str(&format!("  {}: '{}',\n", val, val));
            }
            self.output.push_str("} as const;\n\n");
        }
    }

    fn write_rust_style_enum(&mut self, e: &bgql_syntax::EnumTypeDefinition<'_>) {
        let name = self.interner.get(e.name.value);

        // Generate individual variant types
        for value in &e.values {
            let variant_name = self.interner.get(value.name.value);
            let full_name = format!("{}_{}", name, variant_name);

            match &value.data {
                Some(bgql_syntax::EnumVariantData::Tuple(types, _)) => {
                    // Tuple variant: { __variant: 'Ok', _0: T }
                    self.output
                        .push_str(&format!("export interface {} {{\n", full_name));
                    self.output
                        .push_str(&format!("  readonly __variant: '{}';\n", variant_name));
                    for (i, ty) in types.iter().enumerate() {
                        let ts_type = self.convert_type(ty, self.interner);
                        self.output
                            .push_str(&format!("  readonly _{}: {};\n", i, ts_type));
                    }
                    self.output.push_str("}\n\n");
                }
                Some(bgql_syntax::EnumVariantData::Struct(fields, _)) => {
                    // Struct variant: { __variant: 'Err', message: string }
                    self.output
                        .push_str(&format!("export interface {} {{\n", full_name));
                    self.output
                        .push_str(&format!("  readonly __variant: '{}';\n", variant_name));
                    for field in fields {
                        let field_name = self.interner.get(field.name.value);
                        let ts_type = self.convert_type(&field.ty, self.interner);
                        let optional = self.is_optional(&field.ty);
                        self.output.push_str(&format!(
                            "  readonly {}{}: {};\n",
                            field_name,
                            if optional { "?" } else { "" },
                            ts_type
                        ));
                    }
                    self.output.push_str("}\n\n");
                }
                None => {
                    // Unit variant
                    self.output
                        .push_str(&format!("export interface {} {{\n", full_name));
                    self.output
                        .push_str(&format!("  readonly __variant: '{}';\n", variant_name));
                    self.output.push_str("}\n\n");
                }
            }
        }

        // Generate union type
        let variants: Vec<_> = e
            .values
            .iter()
            .map(|v| format!("{}_{}", name, self.interner.get(v.name.value)))
            .collect();
        self.output.push_str(&format!(
            "export type {} = {};\n\n",
            name,
            variants.join(" | ")
        ));

        // Generate type guards
        self.output
            .push_str(&format!("export const {} = {{\n", name));
        for value in &e.values {
            let variant_name = self.interner.get(value.name.value);
            self.output.push_str(&format!(
                "  is{}: (value: {}): value is {}_{} => value.__variant === '{}',\n",
                variant_name, name, name, variant_name, variant_name
            ));
        }
        self.output.push_str("} as const;\n\n");
    }

    fn write_union_type(&mut self, u: &bgql_syntax::UnionTypeDefinition<'_>) {
        let name = self.interner.get(u.name.value);

        if let Some(desc) = &u.description {
            self.write_jsdoc(desc.value);
        }

        let members: Vec<_> = u
            .members
            .iter()
            .map(|m| self.interner.get(m.value))
            .collect();
        self.output.push_str(&format!(
            "export type {} = {};\n\n",
            name,
            members.join(" | ")
        ));
    }

    fn write_input_type(&mut self, inp: &bgql_syntax::InputObjectTypeDefinition<'_>) {
        let name = self.interner.get(inp.name.value);

        if let Some(desc) = &inp.description {
            self.write_jsdoc(desc.value);
        }

        self.output
            .push_str(&format!("export interface {} {{\n", name));

        for field in &inp.fields {
            self.write_input_field(field);
        }

        self.output.push_str("}\n\n");
    }

    fn write_scalar_type(&mut self, s: &bgql_syntax::ScalarTypeDefinition<'_>) {
        let name = self.interner.get(s.name.value);

        if let Some(desc) = &s.description {
            self.write_jsdoc(desc.value);
        }

        // Custom scalars map to unknown by default
        self.output
            .push_str(&format!("export type {} = unknown;\n\n", name));
    }

    fn write_opaque_type(&mut self, o: &bgql_syntax::OpaqueTypeDefinition<'_>) {
        let name = self.interner.get(o.name.value);
        let underlying = self.convert_type(&o.underlying, self.interner);

        if let Some(desc) = &o.description {
            self.write_jsdoc(desc.value);
        }

        // Use branded type pattern for nominal typing
        self.output.push_str(&format!(
            "export type {} = {} & {{ readonly __brand: '{}' }};\n\n",
            name, underlying, name
        ));
    }

    fn write_type_alias(&mut self, a: &bgql_syntax::TypeAliasDefinition<'_>) {
        let name = self.interner.get(a.name.value);
        let aliased = self.convert_type(&a.aliased, self.interner);

        if let Some(desc) = &a.description {
            self.write_jsdoc(desc.value);
        }

        self.output
            .push_str(&format!("export type {} = {};\n\n", name, aliased));
    }

    fn write_input_union(&mut self, iu: &bgql_syntax::InputUnionTypeDefinition<'_>) {
        let name = self.interner.get(iu.name.value);

        if let Some(desc) = &iu.description {
            self.write_jsdoc(desc.value);
        }

        let members: Vec<_> = iu
            .members
            .iter()
            .map(|m| self.interner.get(m.value))
            .collect();
        self.output.push_str(&format!(
            "export type {} = {};\n\n",
            name,
            members.join(" | ")
        ));
    }

    fn write_field(&mut self, field: &FieldDefinition<'_>) {
        let name = self.interner.get(field.name.value);
        let ts_type = self.convert_type(&field.ty, self.interner);
        let optional = self.is_optional(&field.ty);

        if let Some(desc) = &field.description {
            self.output.push_str(&format!("  /** {} */\n", desc.value));
        }

        self.output.push_str(&format!(
            "  readonly {}{}: {};\n",
            name,
            if optional { "?" } else { "" },
            ts_type
        ));
    }

    fn write_input_field(&mut self, field: &InputValueDefinition<'_>) {
        let name = self.interner.get(field.name.value);
        let ts_type = self.convert_type(&field.ty, self.interner);
        let optional = self.is_optional(&field.ty) || field.default_value.is_some();

        if let Some(desc) = &field.description {
            self.output.push_str(&format!("  /** {} */\n", desc.value));
        }

        self.output.push_str(&format!(
            "  {}{}: {};\n",
            name,
            if optional { "?" } else { "" },
            ts_type
        ));
    }

    fn write_client_sdk(&mut self) {
        self.output.push_str(
            "// =============================================================================\n",
        );
        self.output.push_str("// Client SDK\n");
        self.output.push_str(
            "// =============================================================================\n\n",
        );

        // Collect field info first to avoid borrow conflicts
        let query_fields: Vec<_> = self.get_object_fields("Query");
        let mutation_fields: Vec<_> = self.get_object_fields("Mutation");

        // Generate typed client interface
        self.output.push_str("export interface TypedBgqlClient {\n");

        for (name, return_type, args_type, _) in &query_fields {
            let args_part = if args_type == "void" {
                String::new()
            } else {
                format!(": {}", args_type)
            };
            self.output.push_str(&format!(
                "  {}(variables{}): Promise<Result<{}, Error>>;\n",
                name, args_part, return_type
            ));
        }

        for (name, return_type, args_type, _) in &mutation_fields {
            let args_part = if args_type == "void" {
                String::new()
            } else {
                format!(": {}", args_type)
            };
            self.output.push_str(&format!(
                "  {}(variables{}): Promise<Result<{}, Error>>;\n",
                name, args_part, return_type
            ));
        }

        self.output.push_str("}\n\n");

        // Generate client factory
        self.output
            .push_str("export function createTypedClient(client: BgqlClient): TypedBgqlClient {\n");
        self.output.push_str("  return {\n");

        for (name, _, _, impl_str) in &query_fields {
            self.output.push_str(&format!(
                "    {}: (variables) => client.query(`{}`{}, variables),\n",
                name, impl_str, ""
            ));
        }

        for (name, _, _, impl_str) in &mutation_fields {
            self.output.push_str(&format!(
                "    {}: (variables) => client.mutation(`{}`{}, variables),\n",
                name, impl_str, ""
            ));
        }

        self.output.push_str("  };\n");
        self.output.push_str("}\n\n");
    }

    fn get_object_fields(&self, type_name: &str) -> Vec<(String, String, String, String)> {
        let type_def = extract_types(self.document).into_iter().find(|t| {
            if let TypeDefinition::Object(obj) = t {
                self.interner.get(obj.name.value) == type_name
            } else {
                false
            }
        });

        let Some(TypeDefinition::Object(obj)) = type_def else {
            return Vec::new();
        };

        obj.fields
            .iter()
            .map(|field| {
                let name = self.interner.get(field.name.value).to_string();
                let return_type = self.convert_type(&field.ty, self.interner);

                let args_type = if field.arguments.is_empty() {
                    "void".to_string()
                } else {
                    let args: Vec<_> = field
                        .arguments
                        .iter()
                        .map(|arg| {
                            let arg_name = self.interner.get(arg.name.value);
                            let arg_type = self.convert_type(&arg.ty, self.interner);
                            let optional = self.is_optional(&arg.ty);
                            format!(
                                "{}{}: {}",
                                arg_name,
                                if optional { "?" } else { "" },
                                arg_type
                            )
                        })
                        .collect();
                    format!("{{ {} }}", args.join("; "))
                };

                // Build query string
                let args_str = if field.arguments.is_empty() {
                    String::new()
                } else {
                    let args: Vec<_> = field
                        .arguments
                        .iter()
                        .map(|arg| {
                            let arg_name = self.interner.get(arg.name.value);
                            let arg_type = self.type_to_graphql(&arg.ty);
                            format!("${}: {}", arg_name, arg_type)
                        })
                        .collect();
                    format!("({})", args.join(", "))
                };

                let field_args = if field.arguments.is_empty() {
                    String::new()
                } else {
                    let args: Vec<_> = field
                        .arguments
                        .iter()
                        .map(|arg| {
                            let arg_name = self.interner.get(arg.name.value);
                            format!("{}: ${}", arg_name, arg_name)
                        })
                        .collect();
                    format!("({})", args.join(", "))
                };

                let cap_name = capitalize(&name);
                let impl_str = format!(
                    "query {}{} {{ {}{} }}",
                    cap_name, args_str, name, field_args
                );

                (name, return_type, args_type, impl_str)
            })
            .collect()
    }

    fn write_server_sdk(&mut self) {
        self.output.push_str(
            "// =============================================================================\n",
        );
        self.output.push_str("// Server SDK (Resolvers)\n");
        self.output.push_str(
            "// =============================================================================\n\n",
        );

        // Collect resolver info first to avoid borrow conflicts
        let resolver_types: Vec<_> = self.collect_resolver_types();

        // Generate resolver types for each type
        for (type_name, fields) in &resolver_types {
            self.output.push_str(&format!(
                "export interface {}Resolvers<TContext extends BaseContext = BaseContext> {{\n",
                type_name
            ));
            for (field_name, args_type, return_type) in fields {
                self.output.push_str(&format!(
                    "  {}?: ResolverFn<{}, {}, TContext, {}>;\n",
                    field_name, type_name, args_type, return_type
                ));
            }
            self.output.push_str("}\n\n");
        }

        // Generate combined resolvers type
        self.output
            .push_str("export interface Resolvers<TContext extends BaseContext = BaseContext> {\n");
        for (type_name, _) in &resolver_types {
            self.output.push_str(&format!(
                "  {}?: {}Resolvers<TContext>;\n",
                type_name, type_name
            ));
        }
        self.output.push_str("}\n\n");
    }

    #[allow(clippy::type_complexity)]
    fn collect_resolver_types(&self) -> Vec<(String, Vec<(String, String, String)>)> {
        extract_types(self.document)
            .iter()
            .filter_map(|type_def| {
                if let TypeDefinition::Object(obj) = type_def {
                    let type_name = self.interner.get(obj.name.value).to_string();
                    let fields: Vec<_> = obj
                        .fields
                        .iter()
                        .map(|field| {
                            let field_name = self.interner.get(field.name.value).to_string();
                            let return_type = self.convert_type(&field.ty, self.interner);

                            let args_type = if field.arguments.is_empty() {
                                "Record<string, never>".to_string()
                            } else {
                                let args: Vec<_> = field
                                    .arguments
                                    .iter()
                                    .map(|arg| {
                                        let arg_name = self.interner.get(arg.name.value);
                                        let arg_type = self.convert_type(&arg.ty, self.interner);
                                        format!("{}: {}", arg_name, arg_type)
                                    })
                                    .collect();
                                format!("{{ {} }}", args.join("; "))
                            };

                            (field_name, args_type, return_type)
                        })
                        .collect();
                    Some((type_name, fields))
                } else {
                    None
                }
            })
            .collect()
    }

    fn write_jsdoc(&mut self, doc: &str) {
        self.output.push_str("/**\n");
        for line in doc.lines() {
            self.output.push_str(&format!(" * {}\n", line));
        }
        self.output.push_str(" */\n");
    }

    fn is_optional(&self, ty: &Type<'_>) -> bool {
        matches!(ty, Type::Option(_, _))
    }

    fn type_to_graphql(&self, ty: &Type<'_>) -> String {
        match ty {
            Type::Named(named) => self.interner.get(named.name),
            Type::Option(inner, _) => self.type_to_graphql(inner),
            Type::List(inner, _) => format!("[{}]", self.type_to_graphql(inner)),
            _ => "String".to_string(),
        }
    }
}

impl<'a> TypeConverter for TypeScriptGenerator<'a> {
    fn convert_type(&self, ty: &Type<'_>, interner: &Interner) -> String {
        match ty {
            Type::Named(named) => {
                let name = interner.get(named.name);
                self.convert_scalar(&name)
            }
            Type::Option(inner, _) => {
                format!("{} | null", self.convert_type(inner, interner))
            }
            Type::List(inner, _) => {
                format!("ReadonlyArray<{}>", self.convert_type(inner, interner))
            }
            Type::Generic(gen) => {
                let name = interner.get(gen.name);
                let args: Vec<_> = gen
                    .arguments
                    .iter()
                    .map(|a| self.convert_type(a, interner))
                    .collect();
                format!("{}<{}>", name, args.join(", "))
            }
            Type::Tuple(tuple) => {
                let elements: Vec<_> = tuple
                    .elements
                    .iter()
                    .map(|e| self.convert_type(&e.ty, interner))
                    .collect();
                format!("[{}]", elements.join(", "))
            }
            Type::_Phantom(_) => "never".to_string(),
        }
    }

    fn convert_scalar(&self, name: &str) -> String {
        match name {
            "Int" | "Float" => "number".to_string(),
            "String" | "ID" => "string".to_string(),
            "Boolean" => "boolean".to_string(),
            "DateTime" => "string".to_string(),
            "JSON" => "Record<string, unknown>".to_string(),
            other => other.to_string(),
        }
    }
}

fn capitalize(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(f) => f.to_uppercase().collect::<String>() + chars.as_str(),
    }
}
