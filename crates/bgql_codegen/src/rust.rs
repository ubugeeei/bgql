//! Rust code generator.

use crate::{extract_types, CodegenOptions, TypeConverter};
use bgql_core::Interner;
use bgql_syntax::{Document, FieldDefinition, InputValueDefinition, Type, TypeDefinition};

/// Rust code generator.
pub struct RustGenerator<'a> {
    document: &'a Document<'a>,
    interner: &'a Interner,
    options: &'a CodegenOptions,
    output: String,
}

impl<'a> RustGenerator<'a> {
    pub fn new(
        document: &'a Document<'a>,
        interner: &'a Interner,
        options: &'a CodegenOptions,
    ) -> Self {
        Self {
            document,
            interner,
            options,
            output: String::new(),
        }
    }

    pub fn generate(mut self) -> String {
        self.write_header();
        self.write_imports();
        self.write_types();

        if self.options.client {
            self.write_client_sdk();
        }

        if self.options.server {
            self.write_server_sdk();
        }

        self.output
    }

    fn write_header(&mut self) {
        self.output
            .push_str("//! Generated by Better GraphQL (bgql)\n");
        self.output
            .push_str("//! DO NOT EDIT - this file is auto-generated\n\n");
        self.output.push_str("#![allow(dead_code)]\n");
        self.output.push_str("#![allow(unused_imports)]\n\n");
    }

    fn write_imports(&mut self) {
        self.output
            .push_str("use serde::{Deserialize, Serialize};\n");
        self.output.push_str("use std::collections::HashMap;\n");
        if self.options.client || self.options.server {
            self.output.push_str("use async_trait::async_trait;\n");
        }
        self.output.push('\n');
    }

    fn write_types(&mut self) {
        self.output.push_str(
            "// =============================================================================\n",
        );
        self.output.push_str("// Types\n");
        self.output.push_str(
            "// =============================================================================\n\n",
        );

        for type_def in extract_types(self.document) {
            match type_def {
                TypeDefinition::Object(obj) => self.write_struct(obj),
                TypeDefinition::Interface(iface) => self.write_trait(iface),
                TypeDefinition::Enum(e) => self.write_enum(e),
                TypeDefinition::Union(u) => self.write_union(u),
                TypeDefinition::Input(inp) => self.write_input(inp),
                TypeDefinition::Scalar(s) => self.write_scalar(s),
                TypeDefinition::Opaque(o) => self.write_newtype(o),
                TypeDefinition::TypeAlias(a) => self.write_type_alias(a),
                TypeDefinition::InputUnion(iu) => self.write_input_union(iu),
            }
        }
    }

    fn write_struct(&mut self, obj: &bgql_syntax::ObjectTypeDefinition<'_>) {
        let name = self.interner.get(obj.name.value);

        if let Some(desc) = &obj.description {
            self.output
                .push_str(&format!("/// {}\n", desc.value.replace('\n', "\n/// ")));
        }

        self.output
            .push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
        self.output.push_str(&format!("pub struct {} {{\n", name));

        for field in &obj.fields {
            self.write_struct_field(field);
        }

        self.output.push_str("}\n\n");
    }

    fn write_trait(&mut self, iface: &bgql_syntax::InterfaceTypeDefinition<'_>) {
        let name = self.interner.get(iface.name.value);

        if let Some(desc) = &iface.description {
            self.output
                .push_str(&format!("/// {}\n", desc.value.replace('\n', "\n/// ")));
        }

        self.output.push_str(&format!("pub trait {} {{\n", name));

        for field in &iface.fields {
            let field_name = self.interner.get(field.name.value);
            let rust_type = self.convert_type(&field.ty, self.interner);
            self.output.push_str(&format!(
                "    fn {}(&self) -> {};\n",
                to_snake_case(&field_name),
                rust_type
            ));
        }

        self.output.push_str("}\n\n");
    }

    fn write_enum(&mut self, e: &bgql_syntax::EnumTypeDefinition<'_>) {
        let name = self.interner.get(e.name.value);

        if let Some(desc) = &e.description {
            self.output
                .push_str(&format!("/// {}\n", desc.value.replace('\n', "\n/// ")));
        }

        // Check if any values have data (Rust-style enum)
        let has_data = e.values.iter().any(|v| v.data.is_some());

        if has_data {
            self.output
                .push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
            self.output.push_str("#[serde(tag = \"__variant\")]\n");
        } else {
            self.output.push_str(
                "#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\n",
            );
        }

        self.output.push_str(&format!("pub enum {} {{\n", name));

        for value in &e.values {
            let variant_name = self.interner.get(value.name.value);

            if let Some(desc) = &value.description {
                self.output.push_str(&format!("    /// {}\n", desc.value));
            }

            match &value.data {
                Some(bgql_syntax::EnumVariantData::Tuple(types, _)) => {
                    let type_list: Vec<_> = types
                        .iter()
                        .map(|t| self.convert_type(t, self.interner))
                        .collect();
                    self.output.push_str(&format!(
                        "    {}({}),\n",
                        variant_name,
                        type_list.join(", ")
                    ));
                }
                Some(bgql_syntax::EnumVariantData::Struct(fields, _)) => {
                    self.output.push_str(&format!("    {} {{\n", variant_name));
                    for field in fields {
                        let field_name = self.interner.get(field.name.value);
                        let rust_type = self.convert_type(&field.ty, self.interner);
                        self.output.push_str(&format!(
                            "        {}: {},\n",
                            to_snake_case(&field_name),
                            rust_type
                        ));
                    }
                    self.output.push_str("    },\n");
                }
                None => {
                    self.output.push_str(&format!("    {},\n", variant_name));
                }
            }
        }

        self.output.push_str("}\n\n");
    }

    fn write_union(&mut self, u: &bgql_syntax::UnionTypeDefinition<'_>) {
        let name = self.interner.get(u.name.value);

        if let Some(desc) = &u.description {
            self.output
                .push_str(&format!("/// {}\n", desc.value.replace('\n', "\n/// ")));
        }

        self.output
            .push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
        self.output.push_str("#[serde(untagged)]\n");
        self.output.push_str(&format!("pub enum {} {{\n", name));

        for member in &u.members {
            let member_name = self.interner.get(member.value);
            self.output
                .push_str(&format!("    {}({}),\n", member_name, member_name));
        }

        self.output.push_str("}\n\n");
    }

    fn write_input(&mut self, inp: &bgql_syntax::InputObjectTypeDefinition<'_>) {
        let name = self.interner.get(inp.name.value);

        if let Some(desc) = &inp.description {
            self.output
                .push_str(&format!("/// {}\n", desc.value.replace('\n', "\n/// ")));
        }

        self.output
            .push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
        self.output.push_str(&format!("pub struct {} {{\n", name));

        for field in &inp.fields {
            self.write_input_field(field);
        }

        self.output.push_str("}\n\n");
    }

    fn write_scalar(&mut self, s: &bgql_syntax::ScalarTypeDefinition<'_>) {
        let name = self.interner.get(s.name.value);

        if let Some(desc) = &s.description {
            self.output
                .push_str(&format!("/// {}\n", desc.value.replace('\n', "\n/// ")));
        }

        // Custom scalars are type aliases to serde_json::Value
        self.output
            .push_str(&format!("pub type {} = serde_json::Value;\n\n", name));
    }

    fn write_newtype(&mut self, o: &bgql_syntax::OpaqueTypeDefinition<'_>) {
        let name = self.interner.get(o.name.value);
        let underlying = self.convert_type(&o.underlying, self.interner);

        if let Some(desc) = &o.description {
            self.output
                .push_str(&format!("/// {}\n", desc.value.replace('\n', "\n/// ")));
        }

        self.output
            .push_str("#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\n");
        self.output.push_str("#[serde(transparent)]\n");
        self.output
            .push_str(&format!("pub struct {}({});\n\n", name, underlying));

        // Generate From impl
        self.output
            .push_str(&format!("impl From<{}> for {} {{\n", underlying, name));
        self.output
            .push_str(&format!("    fn from(value: {}) -> Self {{\n", underlying));
        self.output.push_str("        Self(value)\n");
        self.output.push_str("    }\n");
        self.output.push_str("}\n\n");
    }

    fn write_type_alias(&mut self, a: &bgql_syntax::TypeAliasDefinition<'_>) {
        let name = self.interner.get(a.name.value);
        let aliased = self.convert_type(&a.aliased, self.interner);

        if let Some(desc) = &a.description {
            self.output
                .push_str(&format!("/// {}\n", desc.value.replace('\n', "\n/// ")));
        }

        self.output
            .push_str(&format!("pub type {} = {};\n\n", name, aliased));
    }

    fn write_input_union(&mut self, iu: &bgql_syntax::InputUnionTypeDefinition<'_>) {
        let name = self.interner.get(iu.name.value);

        if let Some(desc) = &iu.description {
            self.output
                .push_str(&format!("/// {}\n", desc.value.replace('\n', "\n/// ")));
        }

        self.output
            .push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
        self.output.push_str("#[serde(untagged)]\n");
        self.output.push_str(&format!("pub enum {} {{\n", name));

        for member in &iu.members {
            let member_name = self.interner.get(member.value);
            self.output
                .push_str(&format!("    {}({}),\n", member_name, member_name));
        }

        self.output.push_str("}\n\n");
    }

    fn write_struct_field(&mut self, field: &FieldDefinition<'_>) {
        let name = self.interner.get(field.name.value);
        let rust_type = self.convert_type(&field.ty, self.interner);

        if let Some(desc) = &field.description {
            self.output.push_str(&format!("    /// {}\n", desc.value));
        }

        // Add serde rename if field name is a Rust keyword or needs conversion
        let snake_name = to_snake_case(&name);
        if snake_name != name {
            self.output
                .push_str(&format!("    #[serde(rename = \"{}\")]\n", name));
        }

        self.output
            .push_str(&format!("    pub {}: {},\n", snake_name, rust_type));
    }

    fn write_input_field(&mut self, field: &InputValueDefinition<'_>) {
        let name = self.interner.get(field.name.value);
        let rust_type = self.convert_type(&field.ty, self.interner);

        if let Some(desc) = &field.description {
            self.output.push_str(&format!("    /// {}\n", desc.value));
        }

        let snake_name = to_snake_case(&name);
        if snake_name != name {
            self.output
                .push_str(&format!("    #[serde(rename = \"{}\")]\n", name));
        }

        // Skip serializing None values
        if matches!(&field.ty, Type::Option(_, _)) {
            self.output
                .push_str("    #[serde(skip_serializing_if = \"Option::is_none\")]\n");
        }

        self.output
            .push_str(&format!("    pub {}: {},\n", snake_name, rust_type));
    }

    fn write_client_sdk(&mut self) {
        self.output.push_str(
            "// =============================================================================\n",
        );
        self.output.push_str("// Client SDK\n");
        self.output.push_str(
            "// =============================================================================\n\n",
        );

        // Collect query field info first to avoid borrow conflicts
        let query_methods = self.collect_query_methods("Query");

        self.output
            .push_str("/// Type-safe GraphQL client trait.\n");
        self.output.push_str("#[async_trait]\n");
        self.output.push_str("pub trait GraphQLClient {\n");
        self.output.push_str("    type Error;\n\n");

        for (name, args, return_type) in &query_methods {
            self.output.push_str(&format!(
                "    async fn {}(&self{}) -> Result<{}, Self::Error>;\n",
                name, args, return_type
            ));
        }

        self.output.push_str("}\n\n");
    }

    fn collect_query_methods(&self, type_name: &str) -> Vec<(String, String, String)> {
        let type_def = extract_types(self.document).into_iter().find(|t| {
            if let TypeDefinition::Object(obj) = t {
                self.interner.get(obj.name.value) == type_name
            } else {
                false
            }
        });

        let Some(TypeDefinition::Object(obj)) = type_def else {
            return Vec::new();
        };

        obj.fields
            .iter()
            .map(|field| {
                let name = to_snake_case(&self.interner.get(field.name.value));
                let return_type = self.convert_type(&field.ty, self.interner);

                let args = if field.arguments.is_empty() {
                    String::new()
                } else {
                    let arg_list: Vec<_> = field
                        .arguments
                        .iter()
                        .map(|arg| {
                            let arg_name = self.interner.get(arg.name.value);
                            let arg_type = self.convert_type(&arg.ty, self.interner);
                            format!("{}: {}", to_snake_case(&arg_name), arg_type)
                        })
                        .collect();
                    format!(", {}", arg_list.join(", "))
                };

                (name, args, return_type)
            })
            .collect()
    }

    fn write_server_sdk(&mut self) {
        self.output.push_str(
            "// =============================================================================\n",
        );
        self.output.push_str("// Server SDK (Resolvers)\n");
        self.output.push_str(
            "// =============================================================================\n\n",
        );

        // Generate resolver traits for Query and Mutation
        for type_def in extract_types(self.document) {
            if let TypeDefinition::Object(obj) = type_def {
                let name = self.interner.get(obj.name.value);
                if name == "Query" || name == "Mutation" {
                    self.write_resolver_trait(obj, &name);
                }
            }
        }
    }

    fn write_resolver_trait(
        &mut self,
        obj: &bgql_syntax::ObjectTypeDefinition<'_>,
        type_name: &str,
    ) {
        self.output
            .push_str(&format!("/// {} resolvers.\n", type_name));
        self.output.push_str("#[async_trait]\n");
        self.output.push_str(&format!(
            "pub trait {}Resolvers<Ctx: Send + Sync> {{\n",
            type_name
        ));

        for field in &obj.fields {
            let name = self.interner.get(field.name.value);
            let return_type = self.convert_type(&field.ty, self.interner);

            let args = if field.arguments.is_empty() {
                "&self, ctx: &Ctx".to_string()
            } else {
                let arg_list: Vec<_> = field
                    .arguments
                    .iter()
                    .map(|arg| {
                        let arg_name = self.interner.get(arg.name.value);
                        let arg_type = self.convert_type(&arg.ty, self.interner);
                        format!("{}: {}", to_snake_case(&arg_name), arg_type)
                    })
                    .collect();
                format!("&self, ctx: &Ctx, {}", arg_list.join(", "))
            };

            self.output.push_str(&format!(
                "    async fn {}({}) -> Result<{}, Box<dyn std::error::Error + Send + Sync>>;\n",
                to_snake_case(&name),
                args,
                return_type
            ));
        }

        self.output.push_str("}\n\n");
    }
}

impl<'a> TypeConverter for RustGenerator<'a> {
    fn convert_type(&self, ty: &Type<'_>, interner: &Interner) -> String {
        match ty {
            Type::Named(named) => {
                let name = interner.get(named.name);
                self.convert_scalar(&name)
            }
            Type::Option(inner, _) => {
                format!("Option<{}>", self.convert_type(inner, interner))
            }
            Type::List(inner, _) => {
                format!("Vec<{}>", self.convert_type(inner, interner))
            }
            Type::Generic(gen) => {
                let name = interner.get(gen.name);
                let args: Vec<_> = gen
                    .arguments
                    .iter()
                    .map(|a| self.convert_type(a, interner))
                    .collect();
                format!("{}<{}>", name, args.join(", "))
            }
            Type::Tuple(tuple) => {
                let elements: Vec<_> = tuple
                    .elements
                    .iter()
                    .map(|e| self.convert_type(&e.ty, interner))
                    .collect();
                format!("({})", elements.join(", "))
            }
            Type::_Phantom(_) => "()".to_string(),
        }
    }

    fn convert_scalar(&self, name: &str) -> String {
        match name {
            "Int" => "i32".to_string(),
            "Float" => "f64".to_string(),
            "String" => "String".to_string(),
            "ID" => "String".to_string(),
            "Boolean" => "bool".to_string(),
            "DateTime" => "String".to_string(),
            "JSON" => "serde_json::Value".to_string(),
            other => other.to_string(),
        }
    }
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap());
        } else {
            result.push(c);
        }
    }
    result
}
